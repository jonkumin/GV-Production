"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const path = require('path');

const fse = require('fs-extra');

const {
  compact,
  get,
  isEmpty
} = require('lodash');

const {
  EOL
} = require('os');

const sleep = require('../utils/sleep');

const packageProject = require('../utils/packageProject');

const git = require('../utils/git');

const XdnPackageJson = require('../utils/XdnPackageJson');

const getCoreXdnVersion = require('../utils/getCoreXdnVersion');

const buildProject = require('../utils/build');

const {
  readXdnVersion,
  ensureDomainServedByXdnBuild
} = require('../utils/xdn');

const authenticate = require('../prompts/authenticate');

const detectFramework = require('../frameworks/detectFramework');

const {
  DeployError,
  ValidationError
} = require('../utils/errors');

const stdStreamsObserver = require('../utils/stdStreamsObserver');

const {
  XdnCLIError
} = require('../utils/errors');

exports.command = 'deploy [team]';
exports.describe = 'Deploys your project to the Moovweb XDN';
exports.builder = {
  site: {
    type: 'string',
    alias: 's',
    describe: 'Slug of the site to deploy to, using package.json name property by default'
  },
  'skip-build': {
    type: 'boolean',
    describe: 'Skips rebuilding your app and deploys the previous build instead.'
  },
  path: {
    type: 'string',
    describe: "Path to your site's root director. Uses current directory by default",
    default: '.'
  },
  team: {
    type: 'string',
    alias: 't',
    describe: 'The name of the team under which the site will be deployed. The site will be deployed to your private space will be used if omitted.'
  },
  branch: {
    type: 'string',
    alias: 'b',
    describe: 'The name of the source control branch. This is automatically set when using Git.'
  },
  environment: {
    type: 'string',
    alias: 'e',
    describe: 'Environment to deploy to. Uses default environment otherwise'
  },
  'commit-url': {
    type: 'string',
    describe: `Custom commit url. Automatically works for github, bitbucket and gitlab. Git SHA is appended at the end of the provided url.${EOL}` + 'Example: https://github.com/jlord/sheetsee.js/commit/'
  },
  'wait-xdn': {
    type: 'boolean',
    describe: 'Flag indicating if build of your app should wait for it to be distributed to the nearest global XDN POP',
    default: true
  }
};

class DeployCommand {
  constructor(yargs) {
    _defineProperty(this, "run", async () => {
      const {
        context
      } = this._yargs;

      try {
        await this._wrappedRun();
      } catch (e) {
        if (this._buildId) {
          let message = 'Build failed';
          message += ` with error: ${e.message}`;

          if (e.errorDetails) {
            message += `\n${e.errorDetails}`;
          }

          if (e.addToLeDeployerLogs) {
            message += `\n${e.addToLeDeployerLogs}`;
          } // XdnCLIErrors occur in a normal user workflow
          // (failed sign-in, team slug not found, javascript build failure, etc...)
          // in which case we don't want to log the stack trace but just the specific error message
          // and details


          if (e.stack && !(e instanceof XdnCLIError)) {
            message += e.stack;
          }

          await context.api.updateBuild(this._buildId, {
            status: 'failed'
          }, message);
        }

        throw e;
      }
    });

    _defineProperty(this, "_wrappedRun", async () => {
      const {
        context,
        path: givenPath,
        team: teamSlug,
        site,
        branch,
        environment,
        skipBuild,
        commitUrl: customCommitUrl,
        waitXdn
      } = this._yargs;
      const {
        logger,
        isLocalDev
      } = context;
      const framework = await detectFramework();
      context.setLoginAction('deploy');
      await authenticate(context);
      const absolutePath = path.resolve(process.cwd(), givenPath); // Check that package.json is existing or fail the deployment

      const packageJson = XdnPackageJson.loadPackageJson(givenPath);
      const buildXdnVersion = getCoreXdnVersion();

      if (isEmpty(buildXdnVersion)) {
        throw new DeployError('@xdn/core module has not been installed, please run "xdn init".');
      } // If --site is provided override default $npm_package_name


      const siteSlug = site || packageJson.name;
      const branchName = branch || (await git.currentBranch(absolutePath));
      const isDirtyCommit = await git.isDirty();

      if (isDirtyCommit) {
        logger.warn('You have uncommitted changes. No commit URL will be stored in moovweb.app.');
      }

      const commitUrl = isDirtyCommit ? undefined : await git.commitUrl(absolutePath, customCommitUrl);
      logger.title('📋 Deploying to:');
      logger.info(`> team=${teamSlug || 'Private space'}${EOL}> site=${siteSlug}${EOL}${branchName ? `> branch=${branchName}${EOL}` : ''}> environment=${environment || 'default'}${EOL}> xdn-version=${buildXdnVersion}${EOL}${commitUrl ? `> commit-url=${commitUrl}` : ''}`);
      let isFirstBuild = false;
      let {
        build,
        s3SelfSignedProjectPost,
        displayedLogsCount
      } = await logger.step('⌛ Initializing build', async () => {
        const {
          build: {
            id: buildId,
            number: buildNumber,
            environment: {
              initialized: environmentIsInitialized,
              name: environmentName
            }
          },
          s3SelfSignedProjectPost,
          deprecationWarning
        } = await context.api.createBuild({
          siteSlug,
          teamSlug,
          environment,
          xdnVersion: buildXdnVersion,
          branch: branchName,
          framework: get(framework, 'key'),
          commitUrl
        }); // Capture the build ID immediately so that we can fail the build on any errors.

        this._buildId = buildId;
        logger.info(`> build=${buildNumber}`);

        if (deprecationWarning) {
          logger.warn(deprecationWarning);
        }

        isFirstBuild = !environmentIsInitialized;

        if (isFirstBuild) {
          logger.warn(`> Since this is the first deployment to the ${environmentName} environment, it will take longer than subsequent deployments.`);
        }

        const {
          build,
          displayedLogsCount
        } = await this._streamLogsUntilStatus(context, ['failed', 'initialized', 'uploading']);
        return {
          build,
          s3SelfSignedProjectPost,
          displayedLogsCount
        };
      });

      if (build.status === 'failed') {
        throw new DeployError('Something went wrong while deploying, please check the logs and contact support if the problem persists');
      }

      if (!skipBuild) {
        const streamsObserver = stdStreamsObserver([process.stdout, process.stderr]);

        try {
          await buildProject(this._yargs);
        } catch (e) {
          throw new DeployError('Project build failed', {
            errorDetails: e.stack || e.message,
            addToLeDeployerLogs: streamsObserver.getOutput()
          });
        } finally {
          streamsObserver.detach();
        }
      } // Check that the XDN versions match unless we are overriding the versions for platform development.


      if (isEmpty(process.env.XDN_VERSION_OVERRIDE)) {
        const builtXdnVersion = await readXdnVersion(absolutePath);

        if (buildXdnVersion !== builtXdnVersion) {
          throw new DeployError(`Please rebuild with XDN v${buildXdnVersion}`);
        }
      } // Puts projectRoot/.xdn folder into zip


      const projectZipFile = await packageProject(absolutePath, this._yargs);
      await logger.step('📡️ Uploading...', async () => {
        logger.info('> Uploading package');
        const zipFileStream = fse.createReadStream(projectZipFile);
        await context.api.presignedUploadToS3(s3SelfSignedProjectPost, zipFileStream);
        await context.api.updateBuild(this._buildId, {
          status: 'uploaded'
        });
        await fse.remove(projectZipFile);
      });
      build = await logger.step('⌛ Deploying to the Moovweb XDN...', async () => {
        const {
          build
        } = await this._streamLogsUntilStatus(context, ['failed', 'completed'], displayedLogsCount);

        if (build.status === 'failed') {
          return build;
        } // In local development, we usually mock the edge deployment
        // so this will never respond


        if ((isFirstBuild || waitXdn) && !isLocalDev) {
          logger.warn(`> Verifying that the deployment has reached your nearest global POP...`);
          const ARBITRARY_SERVED_TIMEOUT_MS = 5 * 60 * 1000;
          const served = await ensureDomainServedByXdnBuild(logger, build.environment.dnsDomainName, build.number, ARBITRARY_SERVED_TIMEOUT_MS);

          if (!served) {
            logger.warn('> Build has not yet propagated. If the problem persists please contact support@moovweb.com');
          }
        }

        return build;
      });

      if (build.status === 'completed') {
        const successMsg = `Site deployed on ${build.environment.name} environment ${build.environment.url}`;
        logger.success(`🚀 ${successMsg}`, {
          bold: true
        });
        logger.info(`> Your build is at ${build.consoleUrl}`);
      } else if (build.status === 'failed') {
        throw new DeployError('Something went wrong while deploying, please check the logs and contact support if the problem persists');
      }
    });

    _defineProperty(this, "_streamLogsUntilStatus", async (context, statuses, displayedLogsCount = 0) => {
      const {
        logger
      } = context; // TODO: use subscriptions?

      const LOG_PULL_DELAY = 5000;
      let build;

      while (!build || !statuses.includes(build.status)) {
        await sleep(LOG_PULL_DELAY);
        build = await context.api.getBuild(this._buildId);
        const logs = compact(build.logs.split('\n'));
        const newLogs = logs.slice(displayedLogsCount);
        newLogs.forEach(newLog => logger.debug(newLog));
        displayedLogsCount = logs.length;
      }

      return {
        build,
        displayedLogsCount
      };
    });

    this._yargs = yargs;
    this._buildId = null;
  }
  /**
   * Performs the deploy command. It correctly fails the build (if it has been started)
   * on any error.
   */


}

const validate = yargs => {
  const commitUrl = yargs.commitUrl;

  if (commitUrl && !/(http|https):\/\//.test(commitUrl)) {
    throw new ValidationError('Invalid commit url protocol');
  }
};

exports.handler = async yargs => {
  validate(yargs);
  const command = new DeployCommand(yargs);
  await command.run();
};