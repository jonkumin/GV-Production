"use strict";

const fse = require('fs-extra');

const https = require('https');

const path = require('path');

const sleep = require('./sleep');

const xdnVersionPath = absoluteNextDistDir => path.join(absoluteNextDistDir, '.xdn', 'XDN_VERSION');

exports.checkProjectBuilt = async absoluteNextDistDir => {
  return fse.pathExists(xdnVersionPath(absoluteNextDistDir));
};

exports.readXdnVersion = async absoluteNextDistDir => {
  return (await fse.readFile(xdnVersionPath(absoluteNextDistDir), 'utf8')).trim();
};
/**
 * Checks if the given domain is being served by XDN.
 *
 * Notes:
 * - It checks for response header of `x-xdn-version` which, if it exists,
 * indicates domain being served by XDN.
 *
 * @param {String} domain Domain to check if it is being served by XDN
 */


exports.isDomainServedByXdnBuild = async (logger, domain, build) => {
  const ARBITRARY_CONNECTION_TIMEOUT_MS = 1000;
  return new Promise(resolve => {
    const req = https.request({
      method: 'HEAD',
      host: domain,
      timeout: ARBITRARY_CONNECTION_TIMEOUT_MS
    }, resp => {
      const data = [];
      resp.on('data', chunk => {
        data.push(chunk);
      });
      resp.on('end', () => {
        const xXdnVersion = resp.headers['x-xdn-version'];

        if (xXdnVersion && new RegExp(`^${build} `).test(xXdnVersion)) {
          resolve(true);
          return;
        }

        resolve(false);
      });
    });
    req.on('error', err => {
      logger.verbose(`Failed connecting to ${domain}: ${err && err.message}`); // We resolve with `false` to continue normal operation as this
      // can sometimes happen reasonably.

      resolve(false);
    });
    req.end();
  });
};
/**
 * Ensures that the domain is being served by XDN.
 *
 * Notes:
 * - It continuously checks if the domain is served by XDN and returns only
 * once that is true or the timeout has expired.
 * - Since XDN POPs have multiple edge servers, a response from a single
 * server is not enough for us to ensure that we have waited long enough
 * to avoid user seeing serving errors. Thus we count the number of times
 * we get XDN version so that we can be reasonably certain that the changes
 * have propagated.
 */


exports.ensureDomainServedByXdnBuild = async (logger, domain, build, timeout) => {
  const ARBITRARY_DELAY_BETWEEN_RETRIES_MS = 100;
  const ARBITRARY_DESIRED_RESPONSE_COUNT = 10;
  const startTime = Date.now();
  let count = 0;

  while (startTime + timeout >= Date.now() && count != ARBITRARY_DESIRED_RESPONSE_COUNT) {
    if (await exports.isDomainServedByXdnBuild(logger, domain, build)) {
      ++count;
    }

    await sleep(ARBITRARY_DELAY_BETWEEN_RETRIES_MS);
  }

  return count == ARBITRARY_DESIRED_RESPONSE_COUNT;
};