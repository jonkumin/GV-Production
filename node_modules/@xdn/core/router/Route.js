"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var cookie_1 = require("cookie");
var path_to_regexp_1 = require("path-to-regexp");
var toEdgeRegex_1 = __importDefault(require("../utils/toEdgeRegex"));
var every_1 = __importDefault(require("lodash/every"));
/**
 * @private
 */
var Route = /** @class */ (function () {
    /**
     * Creates a new Route
     * @param criteria A string or an object with `path`, `headers`, and `method`.
     * @param handler A route handler
     */
    function Route(criteria, handler) {
        // allow providing criteria as string path
        if (!criteria || typeof criteria === 'string') {
            criteria = {
                path: criteria,
            };
        }
        this.criteria = criteria;
        this.handler = handler;
        if (this.criteria.path) {
            this.matcher = path_to_regexp_1.match(this.criteria.path, { decode: decodeURIComponent });
        }
    }
    /**
     * Returns params if route matches the request's method, headers, cookies and path.
     * @param req
     * @return The path params if the route matches the current request, otherwise false
     */
    Route.prototype.match = function (req) {
        var params = this.matchPath(req);
        if (params &&
            this.matchQueryParams(req) &&
            this.matchMethod(req) &&
            this.matchHeaders(req) &&
            this.matchCookies(req)) {
            // We wait until now before assigning params to the request so we are sure the route actually matched the request.
            req.params = params;
            return params;
        }
        else {
            return false;
        }
    };
    // Match criteria path to request url
    Route.prototype.matchPath = function (req) {
        if (this.matcher) {
            var result = this.matcher(req.path);
            return result ? result.params : undefined;
        }
        else {
            return {}; // return a match with no params
        }
    };
    // Match criteria method to request method
    Route.prototype.matchMethod = function (req) {
        if (!this.criteria.method || !req.method) {
            return true;
        }
        return new RegExp(this.criteria.method, 'i').test(req.method);
    };
    /**
     * Ensures that the regular expression will be tested anew, without changing its internal state.
     *
     * Notes:
     * - Sometimes users use global for RegExp definitions. In those cases `.test` changes the internal
     * state and leads to different requests on subsequent calls (usually flip-flopping between
     * subsequent requests)
     *
     * @param regexp Regular expression
     * @param value Value to test or array of values to test
     */
    Route.testRegExp = function (regexp, value) {
        if (value == null) {
            return false;
        }
        if (regexp.global) {
            regexp = new RegExp(regexp);
        }
        if (Array.isArray(value)) {
            return value.some(function (v) { return regexp.test(v); });
        }
        else {
            return regexp.test(value);
        }
    };
    // Run thru criteria headers and match with request headers
    Route.prototype.matchHeaders = function (req) {
        if (this.criteria.headers) {
            return Route.matchCriteriaRegexObjectWithRequestObject(this.criteria.headers, req.headers);
        }
        return true;
    };
    // Run thru criteria query and match with request query parameters
    Route.prototype.matchQueryParams = function (req) {
        if (this.criteria.query) {
            // When there's no query params it means there's no way it's a match when criteria is set
            if (!req.query) {
                return false;
            }
            return Route.matchCriteriaRegexObjectWithRequestObject(this.criteria.query, req.query);
        }
        return true;
    };
    // Run thru criteria cookies and match with request cookies
    Route.prototype.matchCookies = function (req) {
        if (this.criteria.cookies) {
            var cookieHeader = req.headers['cookie'];
            if (cookieHeader == null) {
                return false;
            }
            var cookieValue = Array.isArray(cookieHeader) ? cookieHeader.join('; ') : cookieHeader;
            var reqCookies = cookie_1.parse(cookieValue);
            return Route.matchCriteriaRegexObjectWithRequestObject(this.criteria.cookies, reqCookies);
        }
        return true;
    };
    Route.prototype.toString = function () {
        var _a = this.criteria, path = _a.path, criteria = __rest(_a, ["path"]);
        if (Object.keys(criteria).length) {
            return JSON.stringify(this.criteria);
        }
        else {
            return path;
        }
    };
    Route.prototype.toRegex = function () {
        if (this.criteria.path) {
            return path_to_regexp_1.pathToRegexp(this.criteria.path);
        }
        else {
            // For fallbacks we want everything matched so that we can replace everything if needed.
            // We insist on total matching with `^` and `$` because some regex replacement algorithms
            // have issues with correctly applying `.*` in completely greedy manner (e.g. Fastly's `regsuball`)
            return /^.*$/;
        }
    };
    /**
     * Returns criteria json
     * This is consumed by cache metrics that will transform the route to be as similar as in routes file
     */
    Route.prototype.toJson = function () {
        return JSON.stringify(this.criteria, function (key, value) {
            // We have to convert regular expressions to string otherwise it will not be logged
            if (value instanceof RegExp) {
                return value.toString();
            }
            return value;
        });
    };
    /**
     * Returns a string with the regex representation of the route.
     * @returns Regexp string representation of the route
     */
    Route.prototype.toRegexString = function () {
        return this.toRegex().source;
    };
    /**
     * Returns a regex string compatible with the edge regular express parser
     */
    Route.prototype.toEdgeRegexString = function () {
        return toEdgeRegex_1.default(this.toRegex());
    };
    /**
     * Compares criteria object with request object and returns Boolean
     *
     * @param criteriaObj Object that contains the criteria ([key]: regex)
     * @param requestObj Request object that contains ([key]: string | [key]: string[] | undefined)
     *
     * @returns Boolean
     * true when all conditions are matching
     * false if one of the conditions failed
     */
    Route.matchCriteriaRegexObjectWithRequestObject = function (criteriaObj, requestObj) {
        return every_1.default(Object.entries(criteriaObj), function (_a) {
            var _b = __read(_a, 2), name = _b[0], regex = _b[1];
            return Route.testRegExp(regex, requestObj[name]);
        });
    };
    return Route;
}());
exports.default = Route;
