"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = require("lodash");
var constants_1 = require("../constants");
var addBuiltInRoutes_1 = __importDefault(require("./addBuiltInRoutes"));
var BehindEdgeResponseWriter_1 = __importDefault(require("./BehindEdgeResponseWriter"));
var config_1 = __importDefault(require("../config"));
var createEdgeConfig_1 = __importDefault(require("../edge/createEdgeConfig"));
var readBody_1 = __importDefault(require("../utils/readBody"));
var ResponseWriter_1 = __importStar(require("./ResponseWriter"));
var RouteGroup_1 = __importStar(require("./RouteGroup"));
var RouteGroupList_1 = __importDefault(require("./RouteGroupList"));
var uuid_1 = require("uuid");
var RequestContext_1 = __importDefault(require("./RequestContext"));
/**
 * A router.
 */
var Router = /** @class */ (function () {
    function Router(options) {
        var _this = this;
        if (options === void 0) { options = { excludeBuiltInRoutes: false }; }
        this.routeGroups = new RouteGroupList_1.default();
        this.plugins = [];
        this.destinations = {};
        this.nextRouterIndex = 0;
        this.fallbackAdded = false;
        /**
         * Index is used to determine the precedence of a router when routing rules
         * have not resolved to a specific destination. The router with the lowest
         * number wins.
         * @private
         *
         */
        this._index = 0;
        /**
         * Checks headers for validity and updates them as needed.
         *
         * Notes:
         * - If x-request-id is not present we generate it and later inject it into
         * the response.
         * - If accept-encoding includes gzip then we use it but eliminating everything else
         * as we don't support other encodings. If there is no gzip in accept-encoding
         * then we delete it entirely forcing upstream to return uncoded response.
         * - We emulate the edge router by injecting the same headers it injects:
         *    - x-xdn-client-ip
         *    - x-forwarded-for
         */
        this.processRequestHeaders = function (req) {
            if (!req.headers[constants_1.HTTP_HEADERS.xRequestId]) {
                _this.newRequestId = uuid_1.v4();
                req.headers[constants_1.HTTP_HEADERS.xRequestId] = _this.newRequestId;
            }
            var acceptEncoding = req.headers[constants_1.HTTP_HEADERS.acceptEncoding];
            if (typeof acceptEncoding === 'string' && /gzip/.test(acceptEncoding)) {
                req.headers[constants_1.HTTP_HEADERS.acceptEncoding] = 'gzip';
            }
            else {
                delete req.headers[constants_1.HTTP_HEADERS.acceptEncoding];
            }
            // Append the our local address to the x-forwarded-for header. If x-forwarded-for does not exist, we create it.
            var connection = req.connection;
            var localAddress = '127.0.0.1'; // put a default in, in case the underlying environment does not provide Ip.
            if (connection && connection.remoteAddress) {
                localAddress = connection.remoteAddress;
            }
            if (req.headers[constants_1.HTTP_HEADERS.xForwardedFor]) {
                req.headers[constants_1.HTTP_HEADERS.xForwardedFor] = req.headers[constants_1.HTTP_HEADERS.xForwardedFor] + ", " + localAddress;
            }
            else {
                req.headers[constants_1.HTTP_HEADERS.xForwardedFor] = "" + localAddress;
            }
            if (!req.headers[constants_1.HTTP_HEADERS.xXdnClientIp]) {
                // The client Ip is always the left most x-forwarded-for: value.
                req.headers[constants_1.HTTP_HEADERS.xXdnClientIp] = (req.headers[constants_1.HTTP_HEADERS.xForwardedFor]).split(',')[0];
            }
            _this.processRequestDeviceHeaders(req);
            _this.processRequestGeoHeaders(req);
        };
        /**
         * Emulates edge by injecting device headers into the request prior to routing.
         *
         * Notes:
         * - This code must be the same as the the generated edge router.
         * - This code has been directly translated from:
         *    file: xdn/build-lambda/src/outer-edge/fastly/vcl-generator/init-generated-template.vcl
         *    func: recv_set_user_agent_derived_headers()
         * - We emulate the edge router by injecting the same headers it injects:
         *    - x-xdn-device
         *    - x-xdn-vendor
         *    - x-xdn-browser
         *    - x-xdn-device-is-bot
         */
        this.processRequestDeviceHeaders = function (req) {
            var device = 'desktop';
            var vendor = 'generic';
            var isBot = false;
            var browser = 'generic';
            // Note: unlike outer-edge code, we transform everything to lower case for faster matching
            var ua = (req.headers[constants_1.HTTP_HEADERS.userAgent] || '').toLowerCase();
            if (/ipad/.test(ua)) {
                device = 'tablet';
                vendor = 'apple';
            }
            else if (/ip(hone|od)/.test(ua)) {
                device = 'smartphone';
                vendor = 'apple';
            }
            else if (/android.*(mobile|mini)/.test(ua)) {
                device = 'smartphone';
                vendor = 'android';
            }
            else if (/android/.test(ua)) {
                device = 'tablet';
                vendor = 'android';
            }
            else if (/opera mobi/.test(ua)) {
                device = 'smartphone';
                vendor = 'android';
            }
            else if (/playbook u rim tablet/.test(ua)) {
                device = 'tablet';
                vendor = 'blackberry';
            }
            else if (/hp-tablet.*touchpad/.test(ua)) {
                device = 'tablet';
                vendor = 'hp';
            }
            else if (/kindle\/3/.test(ua)) {
                device = 'tablet';
                vendor = 'kindle';
            }
            else if (/mobile.+firefox/.test(ua)) {
                device = 'mobile';
                vendor = 'firefoxos';
            }
            else if (/^htc/.test(ua)) {
                device = 'smartphone';
                vendor = 'htc';
            }
            else if (/fennec/.test(ua)) {
                device = 'smartphone';
                vendor = 'fennec';
            }
            else if (/iemobile/.test(ua)) {
                device = 'smartphone';
                vendor = 'microsoft';
            }
            else if (/blackberry/.test(ua) || /bb10.*mobile/.test(ua)) {
                device = 'smartphone';
                vendor = 'blackberry';
            }
            else if (/gt-.*build\/gingerbread/.test(ua)) {
                device = 'smartphone';
                vendor = 'android';
            }
            else if (/symbianos.*applewebkit/.test(ua)) {
                device = 'smartphone';
                vendor = 'symbian';
            }
            else if (/symbian/.test(ua) ||
                /^sonyericsson/.test(ua) ||
                /^nokia/.test(ua) ||
                /^samsung/.test(ua) ||
                /^lg/.test(ua) ||
                /bada/.test(ua) ||
                /blazer/.test(ua) ||
                /cellphone/.test(ua) ||
                // /iemobile/.test(ua) || duplicate - this case never hits because it matches above
                /midp-2.0/.test(ua) ||
                /u990/.test(ua) ||
                /netfront/.test(ua) ||
                /opera mini/.test(ua) ||
                /palm/.test(ua) ||
                /nintendo wii/.test(ua) ||
                /playstation portable/.test(ua) ||
                /portalmmm/.test(ua) ||
                /proxinet/.test(ua) ||
                /sonyericsson/.test(ua) ||
                // /symbian/.test(ua) || duplicate
                /windows\ ?ce/.test(ua) ||
                /winwap/.test(ua) ||
                /eudoraweb/.test(ua) ||
                // /htc/.test(ua) || duplicate
                /240x320/.test(ua) ||
                /avantgo/.test(ua)) {
                device = 'mobile';
            }
            if (/bot/.test(ua) ||
                /crawler/.test(ua) ||
                /headless/.test(ua) ||
                /prerender/.test(ua) ||
                /preview/.test(ua) ||
                /scanner/.test(ua) ||
                /slurp/.test(ua) ||
                /spider/.test(ua) ||
                /(developers.google.com\/+\/web\/snippet|embedly|facebookexternalhit|flipboard|googlepagespeed|google page speed)/.test(ua) ||
                /(ia_archiver|moov-prerender-cache-exerciser|nuzzel|outbrain|pinterest|qwantify|tumblr|vkshare)/.test(ua) ||
                /(w3c_validator|whatsapp|xing-contenttabreceiver|yahoo)/.test(ua)) {
                isBot = true;
            }
            else {
                isBot = false;
            }
            if (/edge/.test(ua)) {
                browser = 'edge';
            }
            else if (/chrome|chromium|crios/.test(ua)) {
                browser = 'chrome';
            }
            else if (/firefox/.test(ua)) {
                browser = 'firefox';
            }
            else if (/opera|opr/.test(ua)) {
                browser = 'opera';
            }
            else if (/msie/.test(ua) || /trident/.test(ua)) {
                browser = 'msie';
            }
            else if (/safari/.test(ua)) {
                browser = 'safari';
            }
            req.headers[constants_1.HTTP_HEADERS.xXdnDevice] = device;
            req.headers[constants_1.HTTP_HEADERS.xXdnDeviceIsBot] = isBot ? '1' : '0';
            req.headers[constants_1.HTTP_HEADERS.xXdnVendor] = vendor;
            req.headers[constants_1.HTTP_HEADERS.xXdnBrowser] = browser;
        };
        /**
         * Emulates edge by injecting Geolocation headers into the request prior to routing.
         *  - x-xdn-geo-city
         *  - x-xdn-geo-country-code
         *  - x-xdn-geo-latitude
         *  - x-xdn-geo-longitude
         *  - x-xdn-geo-postal-code
         */
        this.processRequestGeoHeaders = function (req) {
            // Always return geolocation headers
            req.headers[constants_1.HTTP_HEADERS.xXdnGeoCity] = 'San Francisco';
            req.headers[constants_1.HTTP_HEADERS.xXdnGeoCountryCode] = 'US';
            req.headers[constants_1.HTTP_HEADERS.xXdnGeoLatitude] = '37.792094';
            req.headers[constants_1.HTTP_HEADERS.xXdnGeoLongitude] = '-122.401622';
            req.headers[constants_1.HTTP_HEADERS.xXdnGeoPostalCode] = '94104';
        };
        /**
         * Checks if the number of user headers is within the limits.
         *
         * Notes:
         * - User headers are all those that do not have `x-xdn-` prefix.
         * - We check user headers counts in the router because in local
         * development the router is running on "the edge" and we want to
         * simulate the edge behavior (which actually has hard limits on
         * header count - see `XDN_MAX_USER_HEADERS_ALLOWED` for more info)
         */
        this.isUserHeaderCountWithinLimits = function (headers) {
            var userHeaderNames = lodash_1.keys(headers).filter(function (name) { return name.toLowerCase().indexOf(constants_1.XDN_HEADERS_PREFIX) !== 0; });
            return userHeaderNames.length <= constants_1.XDN_MAX_USER_HEADERS_ALLOWED;
        };
        /**
         * Patches writeHead method of the response so that we can do any post-response work.
         *
         * Notes:
         * - Injects response ID header when this same component has generated the request ID.
         * All components that actually generate the request ID before processing the request
         * or going upstream are then also responsible for sending back the request ID downstream.
         * - Return status 542 when there are too many response headers.
         *
         * @param res The response
         */
        this.patchResWriteHead = function (res) {
            var originalWriteHead = res.writeHead;
            res.writeHead = function () {
                var e_1, _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                res.writeHead = originalWriteHead;
                if (_this.newRequestId) {
                    res.setHeader(constants_1.HTTP_HEADERS.xRequestId, _this.newRequestId);
                }
                var HEADERS_ARGS_INDEX = 2;
                var headers = args[HEADERS_ARGS_INDEX];
                if (headers) {
                    try {
                        for (var _b = __values(lodash_1.keys(headers)), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var key = _c.value;
                            res.setHeader(key, headers[key]);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                if (_this.isUserHeaderCountWithinLimits(res.getHeaders())) {
                    res.writeHead.apply(res, __spread(args));
                    return;
                }
                res.writeHead(constants_1.XDN_TOO_MANY_HEADERS_STATUS_CODE, 'Too many response headers');
            };
        };
        /**
         * Handles a request, sending the response by running the handler for each matched route.
         * @param req The request
         * @param res The response
         */
        this.run = function (req, res) { return __awaiter(_this, void 0, void 0, function () {
            var router, context, XDN_ROUTER_DESTINATION, destinationName, _a, _b, route, writer, e_2, e_3_1;
            var e_3, _c;
            var _this = this;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        router = this;
                        context = new RequestContext_1.default();
                        this.processRequestHeaders(req);
                        if (!this.isUserHeaderCountWithinLimits(req.headers)) {
                            res.writeHead(constants_1.XDN_TOO_MANY_HEADERS_STATUS_CODE, 'Too many request headers');
                            res.end();
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, readBody_1.default(req)];
                    case 1:
                        _d.sent();
                        this.patchResWriteHead(res);
                        if (lodash_1.size(this.destinations) > 1) {
                            XDN_ROUTER_DESTINATION = process.env.XDN_ROUTER_DESTINATION;
                            destinationName = (lodash_1.defaultTo(req.headers['x-xdn-destination'], XDN_ROUTER_DESTINATION));
                            if (lodash_1.isEmpty(destinationName)) {
                                // Connascence of algorithm between @xdn/core and @xdn/build-lambda:
                                // when destination cannot be determined by other means, then
                                // we choose the first router that was added to the list.
                                destinationName = lodash_1.minBy(lodash_1.keys(this.destinations), function (destinationName) {
                                    return _this.destinations[destinationName]._index;
                                });
                            }
                            router = this.destinations[destinationName];
                            if (!router) {
                                throw new Error("Routing destination \"" + destinationName + "\" not found.");
                            }
                        }
                        router.plugins.forEach(function (p) { return p.onRequest(req); }); // this gives the plugin an opportunity to update the routes before the request is handled
                        _d.label = 2;
                    case 2:
                        _d.trys.push([2, 10, 11, 12]);
                        _a = __values(router.routeGroups.getRoutes()), _b = _a.next();
                        _d.label = 3;
                    case 3:
                        if (!!_b.done) return [3 /*break*/, 9];
                        route = _b.value;
                        if (!route.match(req))
                            return [3 /*break*/, 8];
                        writer = void 0;
                        if (this.isRequestFromEdge(req)) {
                            writer = new BehindEdgeResponseWriter_1.default(req, res, route, context);
                        }
                        else {
                            writer = new ResponseWriter_1.default(req, res, route, context);
                        }
                        _d.label = 4;
                    case 4:
                        _d.trys.push([4, 7, , 8]);
                        return [4 /*yield*/, route.handler(writer)
                            // Stop running routes if the route has defined the send response,
                            // otherwise continue to the next route.
                        ];
                    case 5:
                        _d.sent();
                        return [4 /*yield*/, writer.sendResponse()];
                    case 6:
                        // Stop running routes if the route has defined the send response,
                        // otherwise continue to the next route.
                        if (_d.sent()) {
                            return [2 /*return*/];
                        }
                        return [3 /*break*/, 8];
                    case 7:
                        e_2 = _d.sent();
                        writer.onRouteError(e_2);
                        return [2 /*return*/];
                    case 8:
                        _b = _a.next();
                        return [3 /*break*/, 3];
                    case 9: return [3 /*break*/, 12];
                    case 10:
                        e_3_1 = _d.sent();
                        e_3 = { error: e_3_1 };
                        return [3 /*break*/, 12];
                    case 11:
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_3) throw e_3.error; }
                        return [7 /*endfinally*/];
                    case 12:
                        this.send404(res);
                        return [2 /*return*/];
                }
            });
        }); };
        if (!options.excludeBuiltInRoutes) {
            addBuiltInRoutes_1.default(this);
        }
    }
    /**
     * Returns a manifest of all static assets to be served via router.static
     * @private
     */
    Router.prototype.getStaticAssetManifest = function () {
        return RouteGroup_1.staticAssetManifest;
    };
    /**
     * Allows the lambda handler to add the __js__ backend in the cloud
     * @private
     * @param {String} name
     * @param {BackendOptions} value
     */
    Router.prototype.setBackend = function (name, value) {
        config_1.default.get('backends')[name] = value;
    };
    /**
     * Constructs plugin and pushes it to registered plugins
     * @param {Class} pluginInstance A plugin to use.
     * @returns {Router} A self-reference, suitable for chaining.
     */
    Router.prototype.use = function (pluginInstance) {
        pluginInstance.onRegister(this);
        this.plugins.push(pluginInstance);
        return this;
    };
    /**
     * Adds a named destination to which you can map traffic using the traffic shaping settings in your environment
     * in the XDN developer console
     * @param {String} name The name of the destination
     * @param {Router} router A router to use when handling requests
     * @returns {Router} A self-reference, suitable for chaining.
     */
    Router.prototype.destination = function (name, router) {
        router.setIndex(this.nextRouterIndex++);
        this.destinations[name] = router;
        return this;
    };
    /**
     * Returns all plugins, including those registered on destination routers.
     */
    Router.prototype.getPlugins = function () {
        var e_4, _a;
        var plugins = this.plugins;
        try {
            for (var _b = __values(Object.values(this.destinations)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var router = _c.value;
                plugins = plugins.concat(router.getPlugins());
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return plugins;
    };
    /**
     * Sets the index at which the router has been added to its parent router
     * @private
     * @param {Number} index
     */
    Router.prototype.setIndex = function (index) {
        this._index = index;
    };
    Object.defineProperty(Router.prototype, "index", {
        /**
         * Returns the index at which the router has been added to its parent router
         * @private
         * @returns router's index
         */
        get: function () {
            return this._index;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds a RouteGroup to router and calls route register function for group.
     * @private
     * @param {String} name Group name
     * @param {Function} registerRoutesFn Group route register function
     * @returns {Router} A self-reference, suitable for chaining.
     */
    Router.prototype.group = function (name, registerRoutesFn) {
        if (this.fallbackAdded) {
            throw new Error("Routes cannot be added after the 'fallback' route as they would be unreachable");
        }
        var newGroup = new RouteGroup_1.default(name);
        registerRoutesFn(newGroup);
        this.routeGroups.add(newGroup);
        return this;
    };
    /**
     * Adds a route matching all methods.
     *
     * Example:
     *
     * ```js
     *  new Router().match('/p/:productId', ({ cache, proxy }) => {
     *    cache({
     *      edge: {
     *        maxAgeSeconds: 60 * 60 * 24
     *      }
     *    })
     *
     *    proxy('origin')
     *  })
     * ```
     *
     * @param {String|Object} criteria Either the path as a string or an object with `path`, `method`, and `headers`.
     * @param {Function} handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    Router.prototype.match = function (criteria, handler) {
        return this.group('root', function (routeGroup) { return routeGroup.match(criteria, handler); });
    };
    /**
     * Adds a route matching the given HTTP method.
     *
     * @param {String} method HTTP method
     * @param {String|Object} criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param {Function} handler A handler function that will be called when the route is matched
     * @private
     */
    Router.prototype.matchMethod = function (method, criteria, handler) {
        if (typeof criteria === 'string') {
            return this.match({
                method: method,
                path: criteria,
            }, handler);
        }
        if (criteria.method) {
            throw new Error("Invalid criteria property method passed to call to Router#" + method + ". Specifying a method in the criteria is redundant.");
        }
        return this.match(__assign(__assign({}, criteria), { method: method }), handler);
    };
    /**
     * Adds a route matching `HEAD` HTTP method.
     *
     * @param {String|Object} criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param {Function} handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    Router.prototype.head = function (criteria, handler) {
        return this.matchMethod(constants_1.HTTP_METHODS.head, criteria, handler);
    };
    /**
     * Adds a route matching `GET` HTTP method.
     *
     * @param {String|Object} criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param {Function} handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    Router.prototype.get = function (criteria, handler) {
        return this.matchMethod(constants_1.HTTP_METHODS.get, criteria, handler);
    };
    /**
     * Adds a route matching `POST` HTTP method.
     *
     * @param {String|Object} criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param {Function} handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    Router.prototype.post = function (criteria, handler) {
        return this.matchMethod(constants_1.HTTP_METHODS.post, criteria, handler);
    };
    /**
     * Adds a route matching `DELETE` HTTP method.
     *
     * @param {String|Object} criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param {Function} handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    Router.prototype.delete = function (criteria, handler) {
        return this.matchMethod(constants_1.HTTP_METHODS.delete, criteria, handler);
    };
    /**
     * Adds a route matching `PUT` HTTP method.
     *
     * @param {String|Object} criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param {Function} handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    Router.prototype.put = function (criteria, handler) {
        return this.matchMethod(constants_1.HTTP_METHODS.put, criteria, handler);
    };
    /**
     * Adds a route matching `PATCH` HTTP method.
     *
     * @param {String|Object} criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param {Function} handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    Router.prototype.patch = function (criteria, handler) {
        return this.matchMethod(constants_1.HTTP_METHODS.patch, criteria, handler);
    };
    /**
     * Adds a route matching `OPTIONS` HTTP method.
     *
     * @param {String|Object} criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param {Function} handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    Router.prototype.options = function (criteria, handler) {
        return this.matchMethod(constants_1.HTTP_METHODS.options, criteria, handler);
    };
    /**
     * Adds a route that matches all requests
     * @param {Function} handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    Router.prototype.fallback = function (handler) {
        this.group('fallback', function (routeGroup) { return routeGroup.match(null, handler); });
        this.fallbackAdded = true;
        return this;
    };
    /**
     * Send a 404 response
     * @param res
     */
    Router.prototype.send404 = function (res) {
        res.writeHead(404);
        res.end();
    };
    /**
     * Adds routes for all static assets in a directory tree.
     *
     * **Example**
     *
     * ```js
     *  router.static('public')
     * ```
     *
     * To only serve files matching a particular pattern, use the glob options:
     *
     * ```js
     *  router.static('public', {
     *    glob: '*.css'
     *  })
     * ```
     *
     * By default the path on which files are served corresponds to the path within the directory, so for example, public/css/main.css would be served at '/css/main.css',
     * you can override this using the `path` option:
     *
     * ```js
     *  router.static('public', {
     *    paths: file => ['/assets/ + file] // will serve public/css/main.css at /assets/css/main.css
     *  })
     * ```
     *
     * You can caching or other additional handler logic using the `handler` option:
     *
     * ```js
     *  router.static('public', {
     *    handler: (file) => ({ cache }) => {
     *      cache({
     *        browser: {
     *          maxAgeSeconds: 60 * 60
     *        },
     *        edge: {
     *          maxAgeSeconds: 60 * 60 * 24,
     *          staleWhileRevalidateSeconds: 60 * 60
     *        }
     *      })
     *    }
     *  })
     * ```
     *
     * @param sourcePath The path to a directory containing static assets relative to the root of your project.
     * @param options
     * @returns A self-reference, suitable for chaining.
     */
    Router.prototype.static = function (sourcePath, options) {
        if (options === void 0) { options = {}; }
        return this.group('root', function (routeGroup) { return routeGroup.static(sourcePath, options); });
    };
    /**
     * Returns edge config from current router
     * @private
     */
    Router.prototype.createEdgeConfig = function () {
        return createEdgeConfig_1.default(this);
    };
    /**
     * @private
     */
    Router.prototype.getDestinations = function () {
        return this.destinations;
    };
    /**
     * @private
     */
    Router.prototype.getRouteGroups = function () {
        return this.routeGroups;
    };
    /**
     * Returns an object containing descriptors for routes cached in the service worker.
     * Descriptors are of type: {
     *   route: <regex pattern for route>,
     *   cacheOptions: <CacheOptions object>
     * }
     * @private
     */
    Router.prototype.getCachedRoutes = function () {
        var e_5, _a;
        var results = [];
        var StubWriter = /** @class */ (function (_super) {
            __extends(StubWriter, _super);
            function StubWriter() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.cacheOptions = {};
                _this.cache = function (options) {
                    _this.cacheOptions = options;
                };
                return _this;
            }
            return StubWriter;
        }(ResponseWriter_1.BaseResponseWriter));
        try {
            for (var _b = __values(this.routeGroups.getRoutes()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var route = _c.value;
                var writer = new StubWriter();
                // @ts-ignore Typescript doesn't like that we're passing in the base class here - but we keep ResponseWriter on the handler method for documentation purposes
                route.handler(writer);
                results.push({
                    route: route.toRegexString(),
                    cacheOptions: writer.cacheOptions,
                });
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return results;
    };
    /**
     * Returns true if the request came through XDN edge.
     *
     * Notes:
     * - If the request came through XDN edge then `x-xdn-version` has been injected.
     *
     * @param req The request
     */
    Router.prototype.isRequestFromEdge = function (req) {
        return typeof req.headers['x-xdn-version'] == 'string';
    };
    return Router;
}());
exports.default = Router;
