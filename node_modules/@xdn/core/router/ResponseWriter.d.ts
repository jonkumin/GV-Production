import Route from './Route';
import Request from './Request';
import Response from './Response';
import BackendOptions from './BackendOptions';
import { CacheOptions } from './CacheOptions';
import RequestContext from './RequestContext';
/**
 * @private
 * Having a no-op BaseResponseWriter makes it easy for us to stub out the writer
 * when introspecing the router.  This is needed to implement Router.getPrefetchableRoutes
 */
export declare class BaseResponseWriter {
    constructor(req?: Request, res?: Response, route?: Route);
    cache(options: CacheOptions): void;
    redirect(to: string, statusCode: number): void;
    proxy(backend: string, options?: ProxyOptions): void;
    render(cb: (request: Request, proxy: (backend: string, options: ProxyOptions) => void, params: any) => void): void;
    stream(backend: string): void;
    serveStatic(path: string): void;
    updatePath(destination: string): void;
    setRequestHeader(name: string, value: string): void;
    updateRequestHeader(name: string, match: RegExp, replace: string): void;
    removeRequestHeader(name: string): void;
    setUpstreamResponseHeader(name: string, value: string): void;
    updateUpstreamResponseHeader(name: string, match: RegExp, replace: string): void;
    removeUpstreamResponseHeader(name: string): void;
    setResponseHeader(name: string, value: string): void;
    updateResponseHeader(name: string, match: RegExp, replace: string): void;
    removeResponseHeader(name: string): void;
    addResponseCookie(name: string, value: string): void;
    updateResponseCookie(name: string, match: RegExp, replace: string): void;
    removeResponseCookie(name: string): void;
    addUpstreamResponseCookie(name: string, value: string): void;
    updateUpstreamResponseCookie(name: string, match: RegExp, replace: string): void;
    removeUpstreamResponseCookie(name: string): void;
    send(content: string | (() => string), statusCode: number, statusMessage?: string): void;
    compute(callback: (request: Request, response: Response) => void | Promise<void>): void;
    serviceWorker(path: string): void;
    allowCors(options: CorsOptions): void;
}
/**
 * The API that is provided to route callbacks.
 */
export default class ResponseWriter extends BaseResponseWriter {
    private readonly params;
    request: Request;
    response: Response;
    protected route: Route;
    private streaming;
    private context;
    private cacheKey?;
    private preCacheRequestActions;
    private postCacheRequestActions;
    private createResponseAction?;
    private preCacheResponseActions;
    private postCacheResponseActions;
    /**
     * @param req The request
     * @param res The response
     * @param route The route
     * @param defaultBackend The default backend for proxy when none is provided
     */
    constructor(req: Request, res: Response, route: Route, context: RequestContext);
    /**
     * Called at the end of the request to send the response back to the browser. Methods like proxy,
     * serveStatic, and render will replace this method with one that actually sends a response.
     * @private
     * @returns True if there send response was defined and invoked, otherwise false.
     */
    sendResponse(): Promise<boolean>;
    /**
     * Gathers up user timings and adds them as x-xdn-user-t
     */
    private addUserTimings;
    /**
     * Copies the body, headers, and status from the cached response
     * to the outgoing response.
     * @param cachedResponse The cached response
     */
    private applyCachedResponse;
    /**
     * Rejects the request with status 412 and returns false if ?xdn_prefetch is present and
     * no cached response was found.
     */
    private validatePrefetch;
    /**
     * @param action
     */
    private setCreateResponseAction;
    /**
     * Redirects the browser to a new location.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/p/:productId', ({ redirect }) => {
     *      return redirect('/products/:productId', 301)
     *    })
     * ```
     *
     * @param to The URL to which the browser will be redirected.
     * @param statusCode The HTTP status to return.  Defaults to 301
     */
    redirect: (to: string, statusCode?: number) => void;
    /**
     * Relays the request to the specified backend.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path/with/:variable', ({ proxy }) => {
     *      proxy('legacy', { path: '/some/other/path/with/:variable' })
     *    })
     * ```
     *
     * In this example, we relay the request to the "legacy" backend. In this case, `xdn.config.js` must
     * contain a definition for the `legacy` backend.  For example:
     *
     * ```
     *  // xdn.config.js
     *
     *  module.exports = {
     *    backends: {
     *      legacy: {
     *        domainOrIp: 'legacy.domain.com',
     *        hostHeader: 'domain.com'
     *      }
     *    }
     *  }
     * ```
     *
     * @param backend The name of one of the backends in your `xdn.config.js` file.
     * @param options
     * @returns A promise the resolves once the response has been fetched from the upstream site.
     */
    proxy: (backend: string, options?: ProxyOptions | undefined) => void;
    /**
     * Calls the provided callback to send a response.
     * @param cb Render callback function
     * @deprecated
     */
    render: (cb: (request: Request, proxy: (backend: string, options: ProxyOptions) => void, params: any) => void) => void;
    /**
     * Streams the result from a backend.  Can only be used in development for things
     * like hot-module reloading.
     * @param backend The name of the backend to connect to
     * @private
     */
    stream: (backend: string) => void;
    /**
     * Proxies the response from a given host
     * @private
     * @param backendConfig The backend config
     * @param options
     */
    proxyHost: (backendConfig: BackendOptions, { path, transformRequest, transformResponse, headers }?: ProxyOptions) => void;
    /**
     * Rewrites the request path.
     *
     * Example:
     *
     * ```js
     *  router.get('/products/:id', ({ updatePath }) => {
     *    updatePath('/p/:id')
     *  })
     * ```
     *
     * @param destination a new route path, which can include params captured from the original path
     */
    updatePath: (destination: string) => void;
    /**
     * Responds with a static asset from the specified path.
     *
     * **Example**
     *
     * ```js
     * serveStatic('path/to/asset/from/app/root')
     * ```
     *
     * You can also use variables in the asset path.  For example, to return files under the `assets` directory
     * when the url starts with `/static`:
     *
     * ```
     *  new Router()
     *    .get('/static/:path*', ({ serveStatic }) => {
     *      serveStatic('assets/:path*')
     *    })
     * ```
     *
     * @param path The relative path to the asset from the app's root directory. You can reference path variables using `:variable`.
     * @returns A promise the resolves once the asset has been fetched from storage.
     */
    serveStatic: (path: string) => void;
    /**
     * Sets the caching behavior for both browser and edge.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/p/:productId', ({ cache, proxy }) => {
     *      cache({
     *        browser: {
     *          maxAgeSeconds: 0,
     *          serviceWorkerSeconds: 60 * 60, // 1 hour
     *        },
     *        edge: {
     *          maxAgeSeconds: 60 * 60 * 24 // 24 hours
     *          staleWhileRevalidateSeconds: 60 * 60 // 1 hour
     *        }
     *      })
     *      proxy('origin')
     *    })
     * ```
     *
     * The `cache()` method can be called in the same route where the response is sent, or any prior route.  For example,
     * with Next.js, it is common to use the next plugin to automatically inherit page routes based on Next.js conventions,
     * and use the XDN router simply to add caching:
     *
     * ```
     *  import { Router } = from '@xdn/core/router'
     *  import { createNextPlugin } from '@xdn/next'
     *
     *  const { nextMiddleware, renderNext } = createNextPlugin()
     *
     *  new Router()
     *    .get('/p/:productId', ({ cache, proxy }) => {
     *      cache({
     *        browser: {
     *          maxAgeSeconds: 0,
     *          serviceWorkerSeconds: 60 * 60, // 1 hour
     *        },
     *        edge: {
     *          maxAgeSeconds: 60 * 60 * 24 // 24 hours
     *          staleWhileRevalidateSeconds: 60 * 60 // 1 hour
     *        }
     *      })
     *      proxy('origin')
     *    })
     *    .use(nextMiddleware)
     * ```
     */
    cache: (options: CacheOptions) => void;
    /**
     * Adds or replaces a response header immediately before delivering the response downstream.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ setResponseHeader, proxy }) => {
     *      proxy('origin')
     *      setResponseHeader('some-header', 'some-value')
     *    })
     * ```
     *
     * @param name The case-insensitive name of the response header
     * @param value The value to set
     */
    setResponseHeader: (name: string, value: string) => void;
    private internalSetResponseHeader;
    /**
     * Alters a response header immediately before delivering the response downstream.
     * Use this method to derive the new header value from the existing one.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ updateResponseHeader, proxy }) => {
     *      proxy('origin')
     *      updateResponseHeader('some-header', /some-.*-part/gi, 'some-replacement')
     *    })
     * ```
     *
     * @param name The case-insensitive name of the response header
     * @param match Regex to find the part that should be replaced.
     * @param replace Value that will replace the matched part.
     */
    updateResponseHeader: (name: string, match: RegExp, replace: string) => void;
    private internalUpdateResponseHeader;
    /**
     * Removes a response header immediately before delivering the response downstream.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ removeResponseHeader, proxy }) => {
     *      proxy('origin')
     *      removeResponseHeader('some-header')
     *    })
     * ```
     * @param name The case-insensitive name of the response header
     */
    removeResponseHeader: (name: string) => void;
    private internalRemoveResponseHeader;
    /**
     * Returns an array of values associated with all `set-cookie` headers.
     */
    private getSetCookieValues;
    /**
     * Returns action function for the "add response cookie" operation.
     */
    private getAddResponseCookieAction;
    /**
     * Adds a `set-cookie` header to the response before attempting to cache the response.
     * This does not replace any cookies with the same name - for that you should use `updateUpstreamResponseCookie`.
     * Furthermore, XDN does not cache responses with `set-cookie` so if you wish to add a cookie
     * *after* the response is cached, you should use `addResponseCookie`.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ addUpstreamResponseCookie, proxy }) => {
     *      proxy('origin')
     *      addUpstreamResponseCookie('my-cookie', 'my-cookie-value')
     *    })
     * ```
     *
     * @param name Name of the cookie to add.
     * @param value Value to set
     */
    addUpstreamResponseCookie: (name: string, value: string) => void;
    /**
     * Adds a `set-cookie` header to the response.
     * This does not replace any cookies with the same name - for that you should use `updateResponseCookie`.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ addUpstreamResponseCookie, proxy }) => {
     *      proxy('origin')
     *      addResponseCookie('my-cookie', 'my-cookie-value')
     *    })
     * ```
     *
     * @param name Name of the cookie to add.
     * @param value Value to set
     */
    addResponseCookie: (name: string, value: string) => void;
    /**
     * Returns action function for the "update response cookie" operation.
     *
     * Notes:
     * - Cookie names are case sensitive so we use case sensitive comparison.
     */
    private getUpdateResponseCookieAction;
    /**
     * Updates a `set-cookie` header in the response before attempting to cache the response.
     * If there are multiple cookies with the same name, all of them will be updated.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ updateUpstreamResponseCookie, proxy }) => {
     *      proxy('origin')
     *      updateUpstreamResponseCookie('my-cookie', /Domain=.+;/, 'Domain=mydomain.com;')
     *    })
     * ```
     *
     * @param name Case-insensitive name of the cookie to update
     * @param match Regex to find the part that should be replaced.
     * @param replace Value that will replace the matched part.
     */
    updateUpstreamResponseCookie: (name: string, match: RegExp, replace: string) => void;
    /**
     * Updates a `set-cookie` header in the response. If there are multiple cookies
     * with the same name, all of them will be updated.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ updateUpstreamResponseCookie, proxy }) => {
     *      proxy('origin')
     *      updateUpstreamResponseCookie('my-cookie', /Domain=.+;/, 'Domain=mydomain.com;')
     *    })
     * ```
     *
     * @param name Case-insensitive name of the cookie to update
     * @param match Regex to find the part that should be replaced.
     * @param replace Value that will replace the matched part.
     */
    updateResponseCookie: (name: string, match: RegExp, replace: string) => void;
    /**
     * Returns action function for the "remove response cookie" operation.
     *
     * Notes:
     * - Cookie names are case sensitive so we use case sensitive comparison.
     */
    private getRemoveResponseCookieAction;
    /**
     * Removes a specific `set-cookie` header from the response before attempting to cache the response.
     * If you wish to remove all such headers use `removeUpstreamHeader`.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ removeUpstreamResponseHeader, proxy }) => {
     *      proxy('origin')
     *      removeUpstreamResponseCookie('my-cookie')
     *    })
     * ```
     * @param name The case-insensitive name of the cookie
     */
    removeUpstreamResponseCookie: (name: string) => void;
    /**
     * Removes a specific `set-cookie` header from the response.
     * If you wish to remove all such headers use `removeHeader`.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ removeUpstreamResponseHeader, proxy }) => {
     *      proxy('origin')
     *      removeUpstreamResponseCookie('my-cookie')
     *    })
     * ```
     * @param name The case-insensitive name of the cookie
     */
    removeResponseCookie: (name: string) => void;
    /**
     * Adds or replaces an upstream response header before attempting to cache the response.
     * In local development this is same as calling `setResponseHeader` but on edge it adds
     * a header immediately after the upstream fetch has finished.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ setUpstreamResponseHeader, proxy }) => {
     *      proxy('origin')
     *      setUpstreamResponseHeader('x-xdn-surrogate-key', 'proxy=origin')
     *    })
     * ```
     *
     * @param name The case-insensitive name of the response header
     * @param value The value to set
     */
    setUpstreamResponseHeader: (name: string, value: string) => void;
    /**
     * Alters an upstream response header before attempting to cache the response.
     * Use this method to derive the new header value from the existing one.
     * In local development this is same as calling `updateResponseHeader` but on
     * edge it updates a header immediately after the upstream fetch has finished.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ updateUpstreamResponseHeader, proxy }) => {
     *      proxy('origin')
     *      updateUpstreamResponseHeader('cache-control', /public/gi, 'private')
     *    })
     * ```
     *
     * @param name The case-insensitive name of the response header
     * @param match Regex to find the part that should be replaced.
     * @param replace Value that will replace the matched part.
     */
    updateUpstreamResponseHeader: (name: string, match: RegExp, replace: string) => void;
    /**
     * Removes a response header before attempting to cache the response.
     * In local development this is same as calling `updateUpstreamResponseHeader` but
     * on edge it removes a header immediately after the upstream fetch has finished.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ removeUpstreamResponseHeader, proxy }) => {
     *      proxy('origin')
     *      removeUpstreamResponseHeader(HTTP_HEADERS.setCookie)
     *    })
     * ```
     * @param name The case-insensitive name of the response header
     */
    removeUpstreamResponseHeader: (name: string) => void;
    /**
     * Adds or replaces a request header.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ setRequestHeader, proxy }) => {
     *      setRequestHeader('some-header', 'some-value')
     *      proxy('origin')
     *    })
     * ```
     *
     * @param name The case-insensitive name of the request header
     * @param value The value to set
     */
    setRequestHeader: (name: string, value: string) => void;
    /**
     * Alters a request header. Use this method to derive the new header value from the existing one.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ updateRequestHeader, proxy }) => {
     *      updateRequestHeader('some-header', /some-.*-part/gi, 'some-replacement')
     *      proxy('origin')
     *    })
     * ```
     *
     * @param name The case-insensitive name of the request header
     * @param match Regex to find the part that should be replaced.
     * @param replace Value that will replace the matched part.
     */
    updateRequestHeader: (name: string, match: RegExp, replace: string) => void;
    /**
     * Removes a request header.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', async ({ removeRequestHeader, proxy }) => {
     *      removeRequestHeader('some-header')
     *      proxy('origin')
     *    })
     * ```
     * @param name The case-insensitive name of the request header
     */
    removeRequestHeader: (name: string) => void;
    /**
     * Returns the service worker with proper edge and browser cache headers
     * @param path The path to the service worker relative to the root directory of your app
     *
     * **Example**
     *
     * ```js
     *  new Router()
     *    .get('/service-worker.js', ({ serviceWorker }) => {
     *      serviceWorker('dist/service-worker.js')
     *    })
     * ```
     */
    serviceWorker: (path: string) => void;
    /**
     * Serves an HTML app shell from a static file.
     * @param indexHtmlPath The path to the app shell html file
     *
     * **Example**
     *
     * ```js
     *  new Router()
     *    .fallback(({ appShell }) => {
     *      appShell('dist/index.html')
     *    })
     * ```
     */
    appShell: (indexHtmlPath: string) => void;
    /**
     * Sends the necessary response headers to allow CORS
     * @param config
     *
     * **Example**
     *
     * ```js
     *  new Router()
     *    .match('/api/:path*', ({ allowCors }) => {
     *      allowCors({
     *        origin: '*', // this is the default
     *        methods: ['get', 'post'],
     *        headers: ['x-some-header'],
     *        maxAge: 60 * 60, // one hour
     *        credentials: true
     *      })
     *    })
     * ```
     */
    allowCors: (config?: CorsOptions) => void;
    /**
     * Sends content back to client. If content is a string, the respons will be sent
     * directly from the edge. If it is a function, the request will be computed by a JavaScript worker.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ send }) => {
     *      return send('<html><body>Hello World!</body></html>', 200, 'OK')
     *    })
     * ```
     * @param content The response body as a string
     * @param statusCode The status to send
     * @param statusMessage The status message to send
     */
    send: (content: string | (() => string), statusCode?: number, statusMessage?: string | undefined) => void;
    /**
     * Execute the provided callback function in the cloud. The callback is passed the request and the response.
     *
     * Use this method when you need to compute a response in the cloud rather than at the edge or at build time. A common example
     * is when the response must be computed based on request parameters, headers, or cookies.
     *
     * A common example is to look up the destination for a redirect from an external API:
     *
     * ```js
     *  new Router()
     *    .get('/products/:id', ({ redirect, compute }) => {
     *      compute(async (request, response) => {
     *        const destination = await getDestinationFromAPI(request.params.id)
     *        redirect(destination)
     *      })
     *    })
     * ```
     *
     * This method can be combined with `cache` to compute responses in the cloud and cache them at edge:
     *
     * ```js
     *  new Router()
     *    .get('/products/:id', ({ cache, redirect, compute }) => {
     *      cache({
     *        edge: {
     *          maxAgeSeconds: 60 * 60 * 24,
     *          staleWhileRevalidateSeconds: 60 * 60,
     *        }
     *      })
     *      compute(async (request, response) => {
     *        const destination = await getDestinationFromAPI(request.params.id)
     *        redirect(destination)
     *      })
     *    })
     * ```
     *
     * @param callback A function to run in the cloud to compute the response
     */
    compute: (callback: (request: Request, response: Response) => void | Promise<void>) => void;
    /**
     * Send json error response to client
     * @private
     * @param err
     */
    onRouteError: (err: Error) => void;
}
/**
 * Options for the `proxy` method
 */
export interface ProxyOptions {
    /**
     * Additional headers to send upstream
     */
    headers?: {
        [key: string]: string;
    };
    /**
     * The path for the URL to request from the upstream site. You can reference variables
     * captured by the route pattern using `:variable`.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path/with/:variable', ({ proxy }) => {
     *      proxy('legacy', { path: '/some/other/path/with/:variable' })
     *    })
     * ```
     *
     * Path can also be a function that returns a URL path string, in which case it will be computed in the cloud
     * rather than at build time.
     */
    path?: string | (() => string | undefined);
    /**
     * A function that transforms the request before it is sent to the upstream server. In general, this
     * is used to alter the request headers or body based on some conditional logic.
     */
    transformRequest?: (request: Request) => void;
    /**
     * A function that transforms the response before it is returned to the browser. This function
     * typically alters `response.body` to change the content sent to the browser. It can also add, remove,
     * and alter response headers.
     */
    transformResponse?: (response: Response, request: Request) => void;
}
export interface CorsOptions {
    /**
     * Sets the Access-Control-Allow-Origin header.
     *
     * Access-Control-Allow-Origin specifies either a single origin, which tells browsers to allow that origin to access
     * the resource; or else — for requests without credentials — the "*" wildcard, to tell browsers to allow any
     * origin to access the resource. If omitted, "*"" will be used
     */
    origin?: string;
    /**
     * Sets the Access-Control-Allow-Methods header.
     *
     * The Access-Control-Allow-Methods header specifies the method or methods allowed when accessing the resource. This is used
     * in response to a preflight request. The conditions under which a request is preflighted are discussed above.
     */
    methods?: string[];
    /**
     * Sets the Access-Control-Allow-Headers header.
     *
     * The Access-Control-Allow-Headers header is used in response to a preflight request to indicate which HTTP headers
     * can be used when making the actual request.
     */
    headers?: string[];
    /**
     * Sets the Access-Control-Max-Age header.
     *
     * The Access-Control-Max-Age header indicates how long the results of a preflight request can be cached.
     * For an example of a preflight request, see the above examples.
     */
    maxAge?: number;
    /**
     * Sets the Access-Control-Allow-Credentials header.
     *
     * The Access-Control-Allow-Credentials header Indicates whether or not the response to the request can be exposed
     * when the credentials flag is true. When used as part of a response to a preflight request, this indicates whether
     * or not the actual request can be made using credentials. Note that simple GET requests are not preflighted, and
     * so if a request is made for a resource with credentials, if this header is not returned with the resource, the
     * response is ignored by the browser and not returned to web content.
     */
    credentials?: boolean;
}
