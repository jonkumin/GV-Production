import Route from './Route';
import { RouteCriteria, RouteHandler } from './Router';
/**
 * The contents to be written to static-asset-manifest.json
 * @private
 */
export declare const staticAssetManifest: {
    [key: string]: string[];
};
/**
 * The static asset manifest file name
 * @private
 */
export declare const STATIC_ASSET_MANIFEST_FILE = "static-asset-manifest.json";
/**
 * This class is needed for creating a route group that holds a routes that can
 * be dynamically updated on a local env.
 * @private
 */
export default class RouteGroup {
    readonly name: string;
    private _routes;
    /**
     * @param name Name of the route group - **required**
     */
    constructor(name: string);
    /**
     * Adds route to group.
     * @param criteria The criteria to match.
     * @param handler The handler to use for the route.
     */
    match(criteria: RouteCriteria | string | null, handler: RouteHandler): this;
    /**
     * Adds routes for all files in a directory tree.
     * @private
     * @param sourcePath The path to a directory containing static assets relative to the root of your project.
     * @param options
     * @returns A self-reference, suitable for chaining.
     */
    dir(sourcePath: string, options: StaticOptions): this;
    /**
     * Adds routes for all static assets in a directory tree.
     * @param sourcePath The path to a directory containing static assets relative to the root of your project.
     * @param options
     * @returns A self-reference, suitable for chaining.
     */
    static(sourcePath: string, options: StaticOptions): this;
    /**
     * Since the files are now on S3, we can no longer crawl the file system to
     * determine the routes, so we use the manifest file
     * we use eval('require') to prevent webpack from trying to bundle the manifest, which will fail
     */
    private staticAssetsForPath;
    /**
     * Clears all routes in group.
     * Used for updating routes dynamically for development purpose.
     */
    clear(): this;
    /**
     * Returns the routes in group.
     * @returns Routes in group
     */
    get routes(): Route[];
    /**
     * Returns number of routes in group.
     * @returns Number of routes in the group.
     */
    get length(): number;
}
export interface DirOptions {
    /**
     * The handler to call when each resulting route is matched.
     */
    handler: (dest: string) => RouteHandler;
    /**
     * Limits the files served to only those matching the specified glob pattern.
     * See https://github.com/isaacs/node-glob#glob-primer for the syntax supported.
     */
    glob?: string;
    /**
     * By default the path on which files are served corresponds to the path within the directory, so for example, public/css/main.css would be served at '/css/main.css',
     * you can override this using the `paths` option. For each file, the function is passed the path to the file within the directory. The function
     * should return the URL paths on which the file should be served.
     */
    paths?: (file: string) => string[];
    /**
     * An optional function to sort the files before mapping them to routes
     */
    sort?: (files: string[]) => string[];
    /**
     * Glob pattern of files to exclude
     */
    ignore?: string | string[];
}
export interface StaticOptions extends Partial<DirOptions> {
    /**
     * Add caching or other additional route handling logic here. The function is passed a ResponseWriter, the same as any other route handler would be.
     */
    handler?: (dest: string) => RouteHandler;
}
