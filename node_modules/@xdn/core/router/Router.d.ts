import BackendOptions from './BackendOptions';
import { CacheOptions } from './CacheOptions';
import PluginBase from '../plugins/PluginBase';
import Request from './Request';
import Response from './Response';
import ResponseWriter from './ResponseWriter';
import RouteGroup, { StaticOptions } from './RouteGroup';
import RouteGroupList from './RouteGroupList';
export interface RouterOptions {
    /**
     * If `true`, built in routes under /__xdn__/ will be not be added to the router.
     */
    excludeBuiltInRoutes: boolean;
}
/**
 * A router.
 */
export default class Router {
    readonly routeGroups: RouteGroupList;
    private readonly plugins;
    private readonly destinations;
    private nextRouterIndex;
    private newRequestId?;
    private fallbackAdded;
    /**
     * Index is used to determine the precedence of a router when routing rules
     * have not resolved to a specific destination. The router with the lowest
     * number wins.
     * @private
     *
     */
    private _index;
    constructor(options?: RouterOptions);
    /**
     * Returns a manifest of all static assets to be served via router.static
     * @private
     */
    getStaticAssetManifest(): {
        [key: string]: string[];
    };
    /**
     * Allows the lambda handler to add the __js__ backend in the cloud
     * @private
     * @param {String} name
     * @param {BackendOptions} value
     */
    setBackend(name: string, value: BackendOptions): void;
    /**
     * Constructs plugin and pushes it to registered plugins
     * @param {Class} pluginInstance A plugin to use.
     * @returns {Router} A self-reference, suitable for chaining.
     */
    use(pluginInstance: PluginBase): this;
    /**
     * Adds a named destination to which you can map traffic using the traffic shaping settings in your environment
     * in the XDN developer console
     * @param {String} name The name of the destination
     * @param {Router} router A router to use when handling requests
     * @returns {Router} A self-reference, suitable for chaining.
     */
    destination(name: string, router: Router): this;
    /**
     * Returns all plugins, including those registered on destination routers.
     */
    getPlugins(): PluginBase[];
    /**
     * Sets the index at which the router has been added to its parent router
     * @private
     * @param {Number} index
     */
    setIndex(index: number): void;
    /**
     * Returns the index at which the router has been added to its parent router
     * @private
     * @returns router's index
     */
    get index(): number;
    /**
     * Adds a RouteGroup to router and calls route register function for group.
     * @private
     * @param {String} name Group name
     * @param {Function} registerRoutesFn Group route register function
     * @returns {Router} A self-reference, suitable for chaining.
     */
    group(name: string, registerRoutesFn: (group: RouteGroup) => void): this;
    /**
     * Adds a route matching all methods.
     *
     * Example:
     *
     * ```js
     *  new Router().match('/p/:productId', ({ cache, proxy }) => {
     *    cache({
     *      edge: {
     *        maxAgeSeconds: 60 * 60 * 24
     *      }
     *    })
     *
     *    proxy('origin')
     *  })
     * ```
     *
     * @param {String|Object} criteria Either the path as a string or an object with `path`, `method`, and `headers`.
     * @param {Function} handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    match(criteria: RouteCriteria | string, handler: RouteHandler): this;
    /**
     * Adds a route matching the given HTTP method.
     *
     * @param {String} method HTTP method
     * @param {String|Object} criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param {Function} handler A handler function that will be called when the route is matched
     * @private
     */
    private matchMethod;
    /**
     * Adds a route matching `HEAD` HTTP method.
     *
     * @param {String|Object} criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param {Function} handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    head(criteria: RouteCriteria | string, handler: RouteHandler): this;
    /**
     * Adds a route matching `GET` HTTP method.
     *
     * @param {String|Object} criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param {Function} handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    get(criteria: RouteCriteria | string, handler: RouteHandler): this;
    /**
     * Adds a route matching `POST` HTTP method.
     *
     * @param {String|Object} criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param {Function} handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    post(criteria: RouteCriteria | string, handler: RouteHandler): this;
    /**
     * Adds a route matching `DELETE` HTTP method.
     *
     * @param {String|Object} criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param {Function} handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    delete(criteria: RouteCriteria | string, handler: RouteHandler): this;
    /**
     * Adds a route matching `PUT` HTTP method.
     *
     * @param {String|Object} criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param {Function} handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    put(criteria: RouteCriteria | string, handler: RouteHandler): this;
    /**
     * Adds a route matching `PATCH` HTTP method.
     *
     * @param {String|Object} criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param {Function} handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    patch(criteria: RouteCriteria | string, handler: RouteHandler): this;
    /**
     * Adds a route matching `OPTIONS` HTTP method.
     *
     * @param {String|Object} criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param {Function} handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    options(criteria: RouteCriteria | string, handler: RouteHandler): this;
    /**
     * Adds a route that matches all requests
     * @param {Function} handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    fallback(handler: RouteHandler): this;
    /**
     * Checks headers for validity and updates them as needed.
     *
     * Notes:
     * - If x-request-id is not present we generate it and later inject it into
     * the response.
     * - If accept-encoding includes gzip then we use it but eliminating everything else
     * as we don't support other encodings. If there is no gzip in accept-encoding
     * then we delete it entirely forcing upstream to return uncoded response.
     * - We emulate the edge router by injecting the same headers it injects:
     *    - x-xdn-client-ip
     *    - x-forwarded-for
     */
    private processRequestHeaders;
    /**
     * Emulates edge by injecting device headers into the request prior to routing.
     *
     * Notes:
     * - This code must be the same as the the generated edge router.
     * - This code has been directly translated from:
     *    file: xdn/build-lambda/src/outer-edge/fastly/vcl-generator/init-generated-template.vcl
     *    func: recv_set_user_agent_derived_headers()
     * - We emulate the edge router by injecting the same headers it injects:
     *    - x-xdn-device
     *    - x-xdn-vendor
     *    - x-xdn-browser
     *    - x-xdn-device-is-bot
     */
    private processRequestDeviceHeaders;
    /**
     * Emulates edge by injecting Geolocation headers into the request prior to routing.
     *  - x-xdn-geo-city
     *  - x-xdn-geo-country-code
     *  - x-xdn-geo-latitude
     *  - x-xdn-geo-longitude
     *  - x-xdn-geo-postal-code
     */
    private processRequestGeoHeaders;
    /**
     * Checks if the number of user headers is within the limits.
     *
     * Notes:
     * - User headers are all those that do not have `x-xdn-` prefix.
     * - We check user headers counts in the router because in local
     * development the router is running on "the edge" and we want to
     * simulate the edge behavior (which actually has hard limits on
     * header count - see `XDN_MAX_USER_HEADERS_ALLOWED` for more info)
     */
    private isUserHeaderCountWithinLimits;
    /**
     * Patches writeHead method of the response so that we can do any post-response work.
     *
     * Notes:
     * - Injects response ID header when this same component has generated the request ID.
     * All components that actually generate the request ID before processing the request
     * or going upstream are then also responsible for sending back the request ID downstream.
     * - Return status 542 when there are too many response headers.
     *
     * @param res The response
     */
    private patchResWriteHead;
    /**
     * Handles a request, sending the response by running the handler for each matched route.
     * @param req The request
     * @param res The response
     */
    run: (req: Request, res: Response) => Promise<void>;
    /**
     * Send a 404 response
     * @param res
     */
    private send404;
    /**
     * Adds routes for all static assets in a directory tree.
     *
     * **Example**
     *
     * ```js
     *  router.static('public')
     * ```
     *
     * To only serve files matching a particular pattern, use the glob options:
     *
     * ```js
     *  router.static('public', {
     *    glob: '*.css'
     *  })
     * ```
     *
     * By default the path on which files are served corresponds to the path within the directory, so for example, public/css/main.css would be served at '/css/main.css',
     * you can override this using the `path` option:
     *
     * ```js
     *  router.static('public', {
     *    paths: file => ['/assets/ + file] // will serve public/css/main.css at /assets/css/main.css
     *  })
     * ```
     *
     * You can caching or other additional handler logic using the `handler` option:
     *
     * ```js
     *  router.static('public', {
     *    handler: (file) => ({ cache }) => {
     *      cache({
     *        browser: {
     *          maxAgeSeconds: 60 * 60
     *        },
     *        edge: {
     *          maxAgeSeconds: 60 * 60 * 24,
     *          staleWhileRevalidateSeconds: 60 * 60
     *        }
     *      })
     *    }
     *  })
     * ```
     *
     * @param sourcePath The path to a directory containing static assets relative to the root of your project.
     * @param options
     * @returns A self-reference, suitable for chaining.
     */
    static(sourcePath: string, options?: StaticOptions): this;
    /**
     * Returns edge config from current router
     * @private
     */
    createEdgeConfig(): Promise<import("../edge/types").EdgeConfig>;
    /**
     * @private
     */
    getDestinations(): {
        [name: string]: Router;
    };
    /**
     * @private
     */
    getRouteGroups(): RouteGroupList;
    /**
     * Returns an object containing descriptors for routes cached in the service worker.
     * Descriptors are of type: {
     *   route: <regex pattern for route>,
     *   cacheOptions: <CacheOptions object>
     * }
     * @private
     */
    getCachedRoutes(): CacheManifestEntry[];
    /**
     * Returns true if the request came through XDN edge.
     *
     * Notes:
     * - If the request came through XDN edge then `x-xdn-version` has been injected.
     *
     * @param req The request
     */
    isRequestFromEdge(req: Request): boolean;
}
/**
 * Criteria for matching a request.
 */
export interface RouteCriteria {
    /**
     * Matches a request based on one or more header values. Keys are
     * case-insensitive header names, values are regular expressions to match.
     */
    headers?: {
        [name: string]: RegExp;
    };
    /**
     * Matches a request based on one or more cookie values. Keys are
     * case-insensitive cookie names, values are regular expressions to match.
     */
    cookies?: {
        [name: string]: RegExp;
    };
    /**
     * Matches a request based on one or more query parameter values. Keys are
     * case-sensitive names, values are regular expressions to match.
     */
    query?: {
        [name: string]: RegExp;
    };
    /**
     * Matches a request based on the HTTP method. Instead of this, prefer using
     * `get`, `post`, `put`, `delete`, `options`, and `patch` methods.
     */
    method?: string | RegExp;
    /**
     * Matches a request based on the path. The same path syntax is used by
     * the simple form of the Router classes's `match` method.
     */
    path?: string;
}
/**
 * @private
 */
export interface CacheManifestEntry {
    route: string;
    cacheOptions: CacheOptions;
}
export declare type RouteHandler = (respond: ResponseWriter) => void;
