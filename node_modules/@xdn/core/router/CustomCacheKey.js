"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Groups_1 = __importDefault(require("./Groups"));
var cookie_1 = require("cookie");
exports.CUSTOM_CACHE_KEY_ACTIONS = {
    blacklistAll: 'blacklist-all-query-parameters',
    blacklistSome: 'blacklist-some-query-parameters',
    whitelistSome: 'whitelist-some-query-parameters',
    addValue: 'add-value',
};
/**
 * Allows you to split or normalize the cache space for a given route. Common use cases include:
 *
 * - serving multiple variants of the same URL based on a currency and/or language cookie.
 * - caching different responses based on device type
 * - ignoring all but a specific set of query parameters when looking up a response from the cache.
 *
 * **Example**
 *
 * ```js
 *  import { Router, CustomCacheKey } from '@xdn/core/router'
 *
 *  new Router()
 *    .match('/some-path', ({ cache }) => {
 *      cache({
 *        key: new CustomCacheKey()
 *          .excludeAllQueryParametersExcept('color', 'size')
 *          .addCookie('currency')
 *          .addCookie('location', cookie => {
 *            cookie.group('na').byPattern('us|ca')
 *            cookie.group('eur').byPattern('de|fr|ee')
 *          }),
 *        edge: {
 *          maxAgeSeconds: 60 * 60
 *        }
 *      })
 *    })
 * ```
 */
var CustomCacheKey = /** @class */ (function () {
    function CustomCacheKey() {
        this.config = [];
        this.actions = [];
    }
    /**
     * Excludes the entire query string from the cache key.
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    CustomCacheKey.prototype.excludeAllQueryParameters = function () {
        this.config.push({ action: exports.CUSTOM_CACHE_KEY_ACTIONS.blacklistAll });
        this.actions.push(function (key, srcRequest) {
            key.query = {};
        });
        return this;
    };
    /**
     * Excludes the provided query parameters from the cache key.  All other parameters
     * will still be part of the cache key. We also refer to this as "blacklisting" query parameters.
     * @param {...String} names The names of the query parameters to blacklist
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    CustomCacheKey.prototype.excludeQueryParameters = function () {
        var names = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            names[_i] = arguments[_i];
        }
        this.config.push({
            action: exports.CUSTOM_CACHE_KEY_ACTIONS.blacklistSome,
            names: names,
        });
        this.actions.push(function (key, srcRequest) {
            var e_1, _a;
            try {
                for (var names_1 = __values(names), names_1_1 = names_1.next(); !names_1_1.done; names_1_1 = names_1.next()) {
                    var name_1 = names_1_1.value;
                    delete key.query[name_1];
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (names_1_1 && !names_1_1.done && (_a = names_1.return)) _a.call(names_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
        return this;
    };
    /**
     * Excludes all query parameters except those provided from the cache key.  We also refer to
     * this as "whitelisting" query parameters.  We recommend using this method over `excludeQueryParameters`
     * as it's difficult to know all of the query parameters your application might receive and unexpected
     * query parameters can lead to significantly lower cache hit rates.
     * @param {...String} names The names of the query parameters to whitelist
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    CustomCacheKey.prototype.excludeAllQueryParametersExcept = function () {
        var names = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            names[_i] = arguments[_i];
        }
        this.config.push({
            action: exports.CUSTOM_CACHE_KEY_ACTIONS.whitelistSome,
            names: names,
        });
        this.actions.push(function (key, srcRequest) {
            var toKeep = new Set(names);
            for (var name_2 in key.query) {
                if (!toKeep.has(name_2)) {
                    delete key.query[name_2];
                }
            }
        });
        return this;
    };
    /**
     * Adds a request header to the cache key.
     * This will have no effect on service worker cache.
     * @param {String} name The name of the request header
     * @param {Function} createGroups A function that accepts a `Groups` instance and calls `groups.group(name)` to group multiple values into a single cache key component
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    CustomCacheKey.prototype.addHeader = function (name, createGroups) {
        var _this = this;
        this.actions.push(function (key, srcRequest) {
            var values = srcRequest.headers[name];
            if (!Array.isArray(values)) {
                values = [values];
            }
            if (createGroups) {
                key.headers[name] = _this.createGroupedValue(createGroups, values);
            }
            else {
                key.headers[name] = values;
            }
        });
        return this.addValue("${req:" + name + "}", createGroups);
    };
    /**
     * Creates a key value for a header or cookie based on the specified group creator
     * @param createGroups the GroupCreator
     * @param srcValues The values of the header or cookie in the request
     */
    CustomCacheKey.prototype.createGroupedValue = function (createGroups, srcValues) {
        var groups = new Groups_1.default();
        var result = [];
        createGroups(groups);
        var matchingGroup = this.findMatchingGroup(groups, srcValues);
        if (matchingGroup) {
            result.push(matchingGroup);
        }
        else {
            // if the value doesn't match any group, use the value itself
            result.push.apply(result, __spread(srcValues));
        }
        return result;
    };
    CustomCacheKey.prototype.findMatchingGroup = function (groups, srcValues) {
        var e_2, _a, e_3, _b;
        var _c;
        try {
            for (var _d = __values(groups.groups), _e = _d.next(); !_e.done; _e = _d.next()) {
                var group = _e.value;
                try {
                    for (var srcValues_1 = (e_3 = void 0, __values(srcValues)), srcValues_1_1 = srcValues_1.next(); !srcValues_1_1.done; srcValues_1_1 = srcValues_1.next()) {
                        var value = srcValues_1_1.value;
                        /* istanbul ignore next */
                        if ((_c = group.pattern) === null || _c === void 0 ? void 0 : _c.test(value)) {
                            return group.name;
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (srcValues_1_1 && !srcValues_1_1.done && (_b = srcValues_1.return)) _b.call(srcValues_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    /**
     * Specifies that requests should be cached on a per-device basis.
     * This will have no effect on service worker cache.
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    CustomCacheKey.prototype.addDevice = function () {
        return this.addHeader('x-xdn-device');
    };
    /**
     * Specifies that requests should be cached on a per-vendor basis.
     * This will have no effect on service worker cache.
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    CustomCacheKey.prototype.addVendor = function () {
        return this.addHeader('x-xdn-vendor');
    };
    /**
     * Specifies that requests should be cached differently for bots.
     * This will have no effect on service worker cache.
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    CustomCacheKey.prototype.addIsBot = function () {
        return this.addHeader('x-xdn-device-is-bot');
    };
    /**
     * Specifies that requests should be cached on a per-browser basis.
     * This will have no effect on service worker cache.
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    CustomCacheKey.prototype.addBrowser = function () {
        return this.addHeader('x-xdn-browser');
    };
    /**
     * Adds a cookie to the cache key.
     * This will have no effect on service worker cache.
     * @param {String} name The name of the cookie
     * @param {Function} createGroups An function that accepts a `Groups` instance and calls `groups.group(name)` to group multiple values into a single cache key component
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    CustomCacheKey.prototype.addCookie = function (name, createGroups) {
        var _this = this;
        this.actions.push(function (key, srcRequest) {
            var cookieHeader = srcRequest.headers.cookie || '';
            if (Array.isArray(cookieHeader)) {
                // Based on https://tools.ietf.org/html/rfc6265#section-5.4 we should only get a single cookie header
                // If we get more than one, we, just join them into a single parseable cookie value in case
                // the origin decides to read them all
                cookieHeader = cookieHeader.join(';');
            }
            var cookie = cookie_1.parse(cookieHeader);
            var value = cookie[name];
            if (createGroups) {
                key.cookies[name] = _this.createGroupedValue(createGroups, [value]);
            }
            else {
                key.cookies[name] = value;
            }
        });
        return this.addValue("${req:cookie:" + name + "}", createGroups);
    };
    /**
     * @private
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    CustomCacheKey.prototype.addValue = function (value, createGroups) {
        var action = {
            action: exports.CUSTOM_CACHE_KEY_ACTIONS.addValue,
            value: value,
        };
        if (createGroups != null) {
            var groups = new Groups_1.default();
            createGroups(groups);
            action.groups = groups.toJSON();
        }
        this.config.push(action);
        return this;
    };
    CustomCacheKey.prototype.toJSON = function () {
        return this.config;
    };
    return CustomCacheKey;
}());
exports.default = CustomCacheKey;
