"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var convertParamsToBackReferences_1 = __importDefault(require("../utils/convertParamsToBackReferences"));
var validateBackends_1 = __importDefault(require("../utils/validateBackends"));
var constants_1 = require("../constants");
var ResponseWriter_1 = __importDefault(require("../router/ResponseWriter"));
var validateWriter_1 = require("../router/validateWriter");
/**
 * A substitute implementation of `ResponseWriter` that creates the contents of `xdn.json`, which
 * is used to generate edge code.
 */
var EdgeResponseWriter = /** @class */ (function (_super) {
    __extends(EdgeResponseWriter, _super);
    /**
     * @param req The `HttpRequest` object
     * @param res The `HttpResponse` object
     * @param route The route being hit
     * @param context The request context
     */
    function EdgeResponseWriter(_req, _res, route, context) {
        var _this = _super.call(this, _req, _res, route, context) // istanbul ignore next - this is a known issue with TypeScript
         || this;
        // Many of the methods such as updateRequestHeader assume transform.request
        // and transform.response are initialized to empty arrays by the constructor.
        _this.stream = function () { };
        _this.setRequestHeader = function (name, value) {
            validateWriter_1.validateSetRequestHeader(name);
            _this.edgeConfig.transform.request.push({
                action: constants_1.ACTIONS.setHeader,
                name: name,
                value: value,
            });
        };
        _this.updateRequestHeader = function (name, match, replace) {
            validateWriter_1.validateUpdateRequestHeader(name);
            _this.edgeConfig.transform.request.push({
                action: constants_1.ACTIONS.updateHeader,
                name: name,
                valueRegex: match.source,
                replaceValue: replace,
            });
        };
        _this.removeRequestHeader = function (name) {
            validateWriter_1.validateRemoveRequestHeader(name);
            _this.edgeConfig.transform.request.push({
                action: constants_1.ACTIONS.removeHeader,
                name: name,
            });
        };
        _this.setResponseHeader = function (name, value) {
            validateWriter_1.validateSetResponseHeader(name);
            _this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.setHeader,
                name: name,
                value: value,
            });
        };
        _this.updateResponseHeader = function (name, match, replace) {
            validateWriter_1.validateUpdateResponseHeader(name);
            _this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.updateHeader,
                name: name,
                valueRegex: match.source,
                replaceValue: replace,
            });
        };
        _this.removeResponseHeader = function (name) {
            validateWriter_1.validateRemoveResponseHeader(name);
            _this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.removeHeader,
                name: name,
            });
        };
        _this.setUpstreamResponseHeader = function (name, value) {
            validateWriter_1.validateSetResponseHeader(name);
            _this.edgeConfig.transform.upstreamResponse.push({
                action: constants_1.ACTIONS.setHeader,
                name: name,
                value: value,
            });
        };
        _this.updateUpstreamResponseHeader = function (name, match, replace) {
            validateWriter_1.validateUpdateResponseHeader(name);
            _this.edgeConfig.transform.upstreamResponse.push({
                action: constants_1.ACTIONS.updateHeader,
                name: name,
                valueRegex: match.source,
                replaceValue: replace,
            });
        };
        _this.removeUpstreamResponseHeader = function (name) {
            validateWriter_1.validateRemoveResponseHeader(name);
            _this.edgeConfig.transform.upstreamResponse.push({
                action: constants_1.ACTIONS.removeHeader,
                name: name,
            });
        };
        _this.addResponseCookie = function (name, value) {
            _this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.addCookie,
                name: name,
                value: value,
            });
        };
        _this.updateResponseCookie = function (name, match, replace) {
            _this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.updateCookie,
                name: name,
                valueRegex: match.source,
                replaceValue: replace,
            });
        };
        _this.removeResponseCookie = function (name) {
            _this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.removeCookie,
                name: name,
            });
        };
        _this.addUpstreamResponseCookie = function (name, value) {
            _this.edgeConfig.transform.upstreamResponse.push({
                action: constants_1.ACTIONS.addCookie,
                name: name,
                value: value,
            });
        };
        _this.updateUpstreamResponseCookie = function (name, match, replace) {
            _this.edgeConfig.transform.upstreamResponse.push({
                action: constants_1.ACTIONS.updateCookie,
                name: name,
                valueRegex: match.source,
                replaceValue: replace,
            });
        };
        _this.removeUpstreamResponseCookie = function (name) {
            _this.edgeConfig.transform.upstreamResponse.push({
                action: constants_1.ACTIONS.removeCookie,
                name: name,
            });
        };
        /**
         * Sends a redirect from the edge
         * @param to The destination URL
         * @param statusCode The http response status.
         */
        _this.redirect = function (to, statusCode) {
            if (statusCode === void 0) { statusCode = 302; }
            _this.setEdgeRoute({ action: constants_1.ACTIONS.syntheticRes, statusCode: statusCode });
            _this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.setHeader,
                name: constants_1.HTTP_HEADERS.location,
                value: '${url}',
            }, {
                action: constants_1.ACTIONS.updateHeader,
                name: constants_1.HTTP_HEADERS.location,
                valueRegex: _this.route.toEdgeRegexString(),
                replaceValue: convertParamsToBackReferences_1.default(_this.route.criteria.path, to),
            });
        };
        /**
         * Serves static assets.
         * @param path The request path
         */
        _this.serveStatic = function (path) {
            if (path && !path.startsWith('/'))
                path = "/" + path;
            _this.proxy(constants_1.BACKENDS.static, { path: path });
            return Promise.resolve();
        };
        /**
         * Proxies from the edge
         * @param backend
         * @param config
         * @param config.path
         */
        _this.proxy = function (backend, _a) {
            var _b = _a === void 0 ? {} : _a, path = _b.path, transformResponse = _b.transformResponse, transformRequest = _b.transformRequest;
            validateBackends_1.default(backend);
            if (transformResponse != null || transformRequest != null || typeof path === 'function') {
                backend = constants_1.BACKENDS.js;
            }
            _this.setEdgeRoute({
                action: constants_1.ACTIONS.proxy,
                backend: backend,
                fsPath: typeof path === 'string' ? path : undefined,
            });
            // You can only update the path in the edge when it's static and thus known during build time.
            // Sometimes `path` is a function that is run by the cloud to compute the actual path.
            if (typeof path === 'string') {
                _this.updatePath(path);
            }
            return Promise.resolve();
        };
        /**
         * Rewrites the request path.
         */
        _this.updatePath = function (destination) {
            _this.edgeConfig.transform.request.push({
                action: constants_1.ACTIONS.updatePath,
                valueRegex: _this.route.toEdgeRegexString(),
                replaceValue: convertParamsToBackReferences_1.default(_this.route.criteria.path, destination),
            });
        };
        /**
         * Creates the edge cache config
         * @param config
         */
        _this.cache = function (config) {
            var edge = config.edge, browser = config.browser, key = config.key;
            if (edge) {
                var maxAgeSeconds = edge.maxAgeSeconds, staleWhileRevalidateSeconds = edge.staleWhileRevalidateSeconds, forcePrivateCaching = edge.forcePrivateCaching;
                _this.edgeConfig.cache = {
                    maxAgeSeconds: maxAgeSeconds,
                    staleWhileRevalidateSeconds: staleWhileRevalidateSeconds,
                    forcePrivateCaching: forcePrivateCaching,
                };
                if (key) {
                    _this.edgeConfig.cache.customKey = key.toJSON();
                }
            }
            else if (edge === false) {
                _this.edgeConfig.cache = {
                    disabled: true,
                };
            }
            if (browser || browser === false) {
                var _a = browser || { maxAgeSeconds: 0 }, maxAgeSeconds = _a.maxAgeSeconds, serviceWorkerSeconds = _a.serviceWorkerSeconds;
                if (maxAgeSeconds === 0) {
                    _this.edgeConfig.transform.response.push({
                        action: constants_1.ACTIONS.setHeader,
                        name: constants_1.HTTP_HEADERS.cacheControl,
                        value: 'private, no-store, no-cache',
                    });
                }
                else if (maxAgeSeconds) {
                    // Here we use "private" instead of "public" to prevent downstream CDNs from caching the asset
                    // Since we already have an explicit way to cache at edge, we choose to keep browser and edge
                    // caching totally separate.
                    _this.edgeConfig.transform.response.push({
                        action: constants_1.ACTIONS.setHeader,
                        name: constants_1.HTTP_HEADERS.cacheControl,
                        value: "private, max-age=" + maxAgeSeconds,
                    });
                }
                if (serviceWorkerSeconds) {
                    _this.edgeConfig.transform.response.push({
                        action: constants_1.ACTIONS.setHeader,
                        name: constants_1.HTTP_HEADERS.xSwCacheControl,
                        value: "max-age=" + serviceWorkerSeconds,
                    });
                }
            }
        };
        /**
         * Sends string content back to client. If content is a string, the response will be sent
         * directly from the edge. If it is a function, the request will be computed by a JavaScript worker.
         * @param content The content to send to the browser
         * @param statusCode The HTTP status code
         * @param statusMessage The HTTP status message
         */
        _this.send = function (content, statusCode, statusMessage) {
            if (statusCode === void 0) { statusCode = 200; }
            if (typeof content === 'function') {
                _this.render();
            }
            else {
                _this.setEdgeRoute({
                    action: constants_1.ACTIONS.syntheticRes,
                    statusCode: statusCode,
                    statusMessage: statusMessage,
                    content: content,
                });
            }
        };
        /**
         * Computed responses are always proxied to the serverless backend.
         * @param callback
         */
        _this.compute = function (callback) {
            _this.setEdgeRoute({
                action: constants_1.ACTIONS.proxy,
                backend: constants_1.BACKENDS.js,
            });
        };
        /**
         * Passes request and response to the specified callback, which should
         * handle rendering the response as a string
         */
        _this.render = function () {
            _this.setEdgeRoute({
                action: constants_1.ACTIONS.proxy,
                backend: constants_1.BACKENDS.js,
            });
            return Promise.resolve();
        };
        _this.edgeConfig = {
            transform: {
                request: [],
                upstreamResponse: [],
                response: [],
            },
        };
        return _this;
    }
    /**
     * Sets the edge route and injects the x-xdn-route header value.
     *
     * Notes:
     * - We need `x-xdn-route` header for statistics so we log it in the edge.
     * We thus set it on the request, which allows us to log it, but in the edge
     * code we unset this header before going upstream which avoids any leaking.
     * - route.criteria.path can be null (fallback, or different match method)
     * so we check that the path exists or injecting the request path as a fallback.
     * - We don't allow upstream to dicate the `vary` header - developers can use
     * our custom cache key mechanism which is a superset anyways. The only
     * header we allow in the `vary` is `accept-encoding` which then shards
     * the cache depending on the encoding that the user agent is accepting.
     * In any case we already include `accept-encoding` in the default cache
     * key so including it in `vary` is superfluous *except* that downstream
     * caches might use it.
     *
     * @private
     */
    EdgeResponseWriter.prototype.setEdgeRoute = function (route) {
        this.edgeConfig.route = route;
        this.edgeConfig.transform.upstreamResponse.push({
            action: constants_1.ACTIONS.setHeader,
            name: constants_1.HTTP_HEADERS.vary,
            value: constants_1.HTTP_HEADERS.acceptEncoding,
        });
    };
    return EdgeResponseWriter;
}(ResponseWriter_1.default));
exports.default = EdgeResponseWriter;
